import argparse
import socket
import threading
import subprocess
import shlex
import os
import sys
import ssl
import logging


BUFFER_SIZE = 4096
ENCODING = 'utf-8'
logging.basicConfig(level=logging.INFO, format='[%(asctime)s] %(message)s')


def execute(cmd):
    cmd = cmd.strip()
    if not cmd:
        return ''
    try:
        output = subprocess.check_output(shlex.split(cmd), stderr=subprocess.STDOUT)
        return output.decode(ENCODING)
    except Exception as e:
        return f"Command failed: {str(e)}\n"

def secure_socket(sock, is_server=False):
    context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
    if is_server:
        context.check_hostname = False
        context.verify_mode = ssl.CERT_NONE
        return context.wrap_socket(sock, server_side=True)
    else:
        return context.wrap_socket(sock)


class NetCatServer:
    def __init__(self, args):
        self.args = args
        self.whitelist = args.allow.split(',') if args.allow else []
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        if args.secure:
            self.sock = secure_socket(self.sock, is_server=True)

    def run(self):
        try:
            self.sock.bind((self.args.target, self.args.port))
            self.sock.listen(5)
            logging.info(f"Listening on {self.args.target}:{self.args.port}")
            while True:
                client, addr = self.sock.accept()
                client_ip = addr[0]
                if self.whitelist and client_ip not in self.whitelist:
                    logging.warning(f"Rejected connection from {client_ip}")
                    client.close()
                    continue
                logging.info(f"Accepted connection from {addr}")
                client_thread = threading.Thread(target=self.handle_client, args=(client,))
                client_thread.start()
        except Exception as e:
            logging.error(f"Server error: {e}")
            self.sock.close()

    def handle_client(self, client):
        if self.args.upload:
            self._handle_upload(client)
        elif self.args.execute:
            output = execute(self.args.execute)
            client.send(output.encode(ENCODING))
        elif self.args.command:
            self._shell(client)
        else:
            self._default_response(client)

    def _handle_upload(self, client):
        file_buffer = b''
        while True:
            data = client.recv(BUFFER_SIZE)
            if not data:
                break
            file_buffer += data
        with open(self.args.upload, 'wb') as f:
            f.write(file_buffer)
        client.send(f"Saved file to {self.args.upload}".encode(ENCODING))
        client.close()

    def _shell(self, client):
        try:
            while True:
                client.send(b'BHP: #> ')
                cmd_buffer = b''
                while b'\n' not in cmd_buffer:
                    data = client.recv(BUFFER_SIZE)
                    if not data:
                        return
                    cmd_buffer += data
                cmd = cmd_buffer.decode(ENCODING).strip()
                if cmd.startswith("GET "):
                    self._handle_download(client, cmd[4:].strip())
                else:
                    response = execute(cmd)
                    client.send(response.encode(ENCODING))
        except Exception as e:
            logging.error(f"Shell error: {e}")
            client.close()

    def _handle_download(self, client, filename):
        if os.path.isfile(filename):
            with open(filename, 'rb') as f:
                while True:
                    data = f.read(BUFFER_SIZE)
                    if not data:
                        break
                    client.send(data)
        else:
            client.send(f"File not found: {filename}\n".encode(ENCODING))

    def _default_response(self, client):
        while True:
            data = client.recv(BUFFER_SIZE)
            if not data:
                break
            logging.info(f"Received: {data.decode(ENCODING)}")
            client.send(data)
        client.close()


class NetCatClient:
    def __init__(self, args, buffer):
        self.args = args
        self.buffer = buffer
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        if args.secure:
            self.sock = secure_socket(self.sock)

    def run(self):
        try:
            self.sock.connect((self.args.target, self.args.port))
            if self.buffer:
                self.sock.send(self.buffer)
            while True:
                response = self.sock.recv(BUFFER_SIZE).decode(ENCODING)
                if not response:
                    break
                print(response, end='')
                try:
                    user_input = input()
                    user_input += '\n'
                    self.sock.send(user_input.encode(ENCODING))
                except KeyboardInterrupt:
                    print("\nConnection closed.")
                    self.sock.close()
                    break
        except Exception as e:
            logging.error(f"Client error: {e}")
            self.sock.close()

# --------- ARGUMENT PARSER --------- #
def parse_args():
    parser = argparse.ArgumentParser(
        description='Homemade Netcat in Python',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  Server shell:      python Homemade_Netcat.py -t 0.0.0.0 -p 5555 -l -c
  One-shot exec:     python Homemade_Netcat.py -t 0.0.0.0 -p 5555 -l -e "ls"
  Upload file:       python Homemade_Netcat.py -t 0.0.0.0 -p 5555 -l -u=test.txt
  File download:     echo 'GET test.txt' | python Homemade_Netcat.py -t 127.0.0.1 -p 5555
  Client input:      echo "hello" | python Homemade_Netcat.py -t 127.0.0.1 -p 5555
"""
    )
    parser.add_argument('-c', '--command', action='store_true', help='Initialize a command shell')
    parser.add_argument('-e', '--execute', help='Execute specified command on connection')
    parser.add_argument('-l', '--listen', action='store_true', help='Listen mode (server)')
    parser.add_argument('-p', '--port', type=int, default=5555, help='Port number')
    parser.add_argument('-t', '--target', default='127.0.0.1', help='Target IP')
    parser.add_argument('-u', '--upload', help='Destination file path for upload')
    parser.add_argument('--secure', action='store_true', help='Enable TLS encryption')
    parser.add_argument('--allow', help='Comma-separated list of IPs allowed to connect (server only)')
    return parser.parse_args()


if __name__ == '__main__':
    args = parse_args()
    if args.listen:
        server = NetCatServer(args)
        server.run()
    else:
        buffer = ''
        if not sys.stdin.isatty():
            buffer = sys.stdin.read()
        client = NetCatClient(args, buffer.encode())
        client.run()


